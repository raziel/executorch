// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_EXECUTORCH_H_
#define FLATBUFFERS_GENERATED_SCHEMA_EXECUTORCH_H_

#include "flatbuffers/flatbuffers.h"

namespace executorch {

struct Buffer;
struct BufferBuilder;

struct OutputContainerMetadata;
struct OutputContainerMetadataBuilder;

struct QuantizedSchema;
struct QuantizedSchemaBuilder;

struct Tensor;
struct TensorBuilder;

struct Int;

struct Bool;

struct Double;

struct String;
struct StringBuilder;

struct IntList;
struct IntListBuilder;

struct DoubleList;
struct DoubleListBuilder;

struct BoolList;
struct BoolListBuilder;

struct TensorList;
struct TensorListBuilder;

struct EValue;
struct EValueBuilder;

struct Operator;
struct OperatorBuilder;

struct Kernel;
struct KernelBuilder;

struct Instruction;

struct Chain;
struct ChainBuilder;

struct ExecutionPlan;
struct ExecutionPlanBuilder;

struct Program;
struct ProgramBuilder;

enum class ValueUnion : uint8_t {
  NONE = 0,
  Int = 1,
  Bool = 2,
  Double = 3,
  Tensor = 4,
  String = 5,
  IntList = 6,
  DoubleList = 7,
  BoolList = 8,
  TensorList = 9,
  MIN = NONE,
  MAX = TensorList
};

inline const ValueUnion (&EnumValuesValueUnion())[10] {
  static const ValueUnion values[] = {
    ValueUnion::NONE,
    ValueUnion::Int,
    ValueUnion::Bool,
    ValueUnion::Double,
    ValueUnion::Tensor,
    ValueUnion::String,
    ValueUnion::IntList,
    ValueUnion::DoubleList,
    ValueUnion::BoolList,
    ValueUnion::TensorList
  };
  return values;
}

inline const char * const *EnumNamesValueUnion() {
  static const char * const names[11] = {
    "NONE",
    "Int",
    "Bool",
    "Double",
    "Tensor",
    "String",
    "IntList",
    "DoubleList",
    "BoolList",
    "TensorList",
    nullptr
  };
  return names;
}

inline const char *EnumNameValueUnion(ValueUnion e) {
  if (flatbuffers::IsOutRange(e, ValueUnion::NONE, ValueUnion::TensorList)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValueUnion()[index];
}

template<typename T> struct ValueUnionTraits {
  static const ValueUnion enum_value = ValueUnion::NONE;
};

template<> struct ValueUnionTraits<executorch::Int> {
  static const ValueUnion enum_value = ValueUnion::Int;
};

template<> struct ValueUnionTraits<executorch::Bool> {
  static const ValueUnion enum_value = ValueUnion::Bool;
};

template<> struct ValueUnionTraits<executorch::Double> {
  static const ValueUnion enum_value = ValueUnion::Double;
};

template<> struct ValueUnionTraits<executorch::Tensor> {
  static const ValueUnion enum_value = ValueUnion::Tensor;
};

template<> struct ValueUnionTraits<executorch::String> {
  static const ValueUnion enum_value = ValueUnion::String;
};

template<> struct ValueUnionTraits<executorch::IntList> {
  static const ValueUnion enum_value = ValueUnion::IntList;
};

template<> struct ValueUnionTraits<executorch::DoubleList> {
  static const ValueUnion enum_value = ValueUnion::DoubleList;
};

template<> struct ValueUnionTraits<executorch::BoolList> {
  static const ValueUnion enum_value = ValueUnion::BoolList;
};

template<> struct ValueUnionTraits<executorch::TensorList> {
  static const ValueUnion enum_value = ValueUnion::TensorList;
};

bool VerifyValueUnion(flatbuffers::Verifier &verifier, const void *obj, ValueUnion type);
bool VerifyValueUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ValueUnion> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Int FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t int_val_;

 public:
  Int()
      : int_val_(0) {
  }
  Int(int64_t _int_val)
      : int_val_(flatbuffers::EndianScalar(_int_val)) {
  }
  int64_t int_val() const {
    return flatbuffers::EndianScalar(int_val_);
  }
  void mutate_int_val(int64_t _int_val) {
    flatbuffers::WriteScalar(&int_val_, _int_val);
  }
};
FLATBUFFERS_STRUCT_END(Int, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Bool FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bool_val_;

 public:
  Bool()
      : bool_val_(0) {
  }
  Bool(bool _bool_val)
      : bool_val_(flatbuffers::EndianScalar(static_cast<uint8_t>(_bool_val))) {
  }
  bool bool_val() const {
    return flatbuffers::EndianScalar(bool_val_) != 0;
  }
  void mutate_bool_val(bool _bool_val) {
    flatbuffers::WriteScalar(&bool_val_, static_cast<uint8_t>(_bool_val));
  }
};
FLATBUFFERS_STRUCT_END(Bool, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Double FLATBUFFERS_FINAL_CLASS {
 private:
  double double_val_;

 public:
  Double()
      : double_val_(0) {
  }
  Double(double _double_val)
      : double_val_(flatbuffers::EndianScalar(_double_val)) {
  }
  double double_val() const {
    return flatbuffers::EndianScalar(double_val_);
  }
  void mutate_double_val(double _double_val) {
    flatbuffers::WriteScalar(&double_val_, _double_val);
  }
};
FLATBUFFERS_STRUCT_END(Double, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Instruction FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t op_;
  int8_t padding0__;  int16_t padding1__;
  int32_t x_;
  int8_t n_;
  int8_t padding2__;  int16_t padding3__;

 public:
  Instruction()
      : op_(0),
        padding0__(0),
        padding1__(0),
        x_(0),
        n_(0),
        padding2__(0),
        padding3__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  Instruction(int8_t _op, int32_t _x, int8_t _n)
      : op_(flatbuffers::EndianScalar(_op)),
        padding0__(0),
        padding1__(0),
        x_(flatbuffers::EndianScalar(_x)),
        n_(flatbuffers::EndianScalar(_n)),
        padding2__(0),
        padding3__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  int8_t op() const {
    return flatbuffers::EndianScalar(op_);
  }
  void mutate_op(int8_t _op) {
    flatbuffers::WriteScalar(&op_, _op);
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(int32_t _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  int8_t n() const {
    return flatbuffers::EndianScalar(n_);
  }
  void mutate_n(int8_t _n) {
    flatbuffers::WriteScalar(&n_, _n);
  }
};
FLATBUFFERS_STRUCT_END(Instruction, 12);

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct BufferBuilder {
  typedef Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Buffer::VT_DATA, data);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  if (data) { _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16); }
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return executorch::CreateBuffer(
      _fbb,
      data__);
}

struct OutputContainerMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OutputContainerMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENCODED_STR = 4
  };
  const flatbuffers::String *encoded_str() const {
    return GetPointer<const flatbuffers::String *>(VT_ENCODED_STR);
  }
  flatbuffers::String *mutable_encoded_str() {
    return GetPointer<flatbuffers::String *>(VT_ENCODED_STR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENCODED_STR) &&
           verifier.VerifyString(encoded_str()) &&
           verifier.EndTable();
  }
};

struct OutputContainerMetadataBuilder {
  typedef OutputContainerMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_encoded_str(flatbuffers::Offset<flatbuffers::String> encoded_str) {
    fbb_.AddOffset(OutputContainerMetadata::VT_ENCODED_STR, encoded_str);
  }
  explicit OutputContainerMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OutputContainerMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OutputContainerMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<OutputContainerMetadata> CreateOutputContainerMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> encoded_str = 0) {
  OutputContainerMetadataBuilder builder_(_fbb);
  builder_.add_encoded_str(encoded_str);
  return builder_.Finish();
}

inline flatbuffers::Offset<OutputContainerMetadata> CreateOutputContainerMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *encoded_str = nullptr) {
  auto encoded_str__ = encoded_str ? _fbb.CreateString(encoded_str) : 0;
  return executorch::CreateOutputContainerMetadata(
      _fbb,
      encoded_str__);
}

struct QuantizedSchema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantizedSchemaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QSCHEME = 4,
    VT_SCALE = 6,
    VT_ZERO_POINT = 8,
    VT_SCALES = 10,
    VT_ZERO_POINTS = 12,
    VT_AXIS = 14
  };
  int8_t qscheme() const {
    return GetField<int8_t>(VT_QSCHEME, 0);
  }
  bool mutate_qscheme(int8_t _qscheme = 0) {
    return SetField<int8_t>(VT_QSCHEME, _qscheme, 0);
  }
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  bool mutate_scale(double _scale = 0.0) {
    return SetField<double>(VT_SCALE, _scale, 0.0);
  }
  int32_t zero_point() const {
    return GetField<int32_t>(VT_ZERO_POINT, 0);
  }
  bool mutate_zero_point(int32_t _zero_point = 0) {
    return SetField<int32_t>(VT_ZERO_POINT, _zero_point, 0);
  }
  const executorch::Tensor *scales() const {
    return GetPointer<const executorch::Tensor *>(VT_SCALES);
  }
  executorch::Tensor *mutable_scales() {
    return GetPointer<executorch::Tensor *>(VT_SCALES);
  }
  const executorch::Tensor *zero_points() const {
    return GetPointer<const executorch::Tensor *>(VT_ZERO_POINTS);
  }
  executorch::Tensor *mutable_zero_points() {
    return GetPointer<executorch::Tensor *>(VT_ZERO_POINTS);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis = 0) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_QSCHEME, 1) &&
           VerifyField<double>(verifier, VT_SCALE, 8) &&
           VerifyField<int32_t>(verifier, VT_ZERO_POINT, 4) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyTable(scales()) &&
           VerifyOffset(verifier, VT_ZERO_POINTS) &&
           verifier.VerifyTable(zero_points()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct QuantizedSchemaBuilder {
  typedef QuantizedSchema Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_qscheme(int8_t qscheme) {
    fbb_.AddElement<int8_t>(QuantizedSchema::VT_QSCHEME, qscheme, 0);
  }
  void add_scale(double scale) {
    fbb_.AddElement<double>(QuantizedSchema::VT_SCALE, scale, 0.0);
  }
  void add_zero_point(int32_t zero_point) {
    fbb_.AddElement<int32_t>(QuantizedSchema::VT_ZERO_POINT, zero_point, 0);
  }
  void add_scales(flatbuffers::Offset<executorch::Tensor> scales) {
    fbb_.AddOffset(QuantizedSchema::VT_SCALES, scales);
  }
  void add_zero_points(flatbuffers::Offset<executorch::Tensor> zero_points) {
    fbb_.AddOffset(QuantizedSchema::VT_ZERO_POINTS, zero_points);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(QuantizedSchema::VT_AXIS, axis, 0);
  }
  explicit QuantizedSchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantizedSchema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizedSchema>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizedSchema> CreateQuantizedSchema(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t qscheme = 0,
    double scale = 0.0,
    int32_t zero_point = 0,
    flatbuffers::Offset<executorch::Tensor> scales = 0,
    flatbuffers::Offset<executorch::Tensor> zero_points = 0,
    int32_t axis = 0) {
  QuantizedSchemaBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_axis(axis);
  builder_.add_zero_points(zero_points);
  builder_.add_scales(scales);
  builder_.add_zero_point(zero_point);
  builder_.add_qscheme(qscheme);
  return builder_.Finish();
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER_INDEX = 4,
    VT_SCALAR_TYPE = 6,
    VT_STORAGE_OFFSET = 8,
    VT_SIZES = 10,
    VT_STRIDES = 12,
    VT_REQUIRES_GRAD = 14,
    VT_QUANTIZED_SCHEMA = 16
  };
  uint32_t buffer_index() const {
    return GetField<uint32_t>(VT_BUFFER_INDEX, 0);
  }
  bool mutate_buffer_index(uint32_t _buffer_index = 0) {
    return SetField<uint32_t>(VT_BUFFER_INDEX, _buffer_index, 0);
  }
  int8_t scalar_type() const {
    return GetField<int8_t>(VT_SCALAR_TYPE, 0);
  }
  bool mutate_scalar_type(int8_t _scalar_type = 0) {
    return SetField<int8_t>(VT_SCALAR_TYPE, _scalar_type, 0);
  }
  int32_t storage_offset() const {
    return GetField<int32_t>(VT_STORAGE_OFFSET, 0);
  }
  bool mutate_storage_offset(int32_t _storage_offset = 0) {
    return SetField<int32_t>(VT_STORAGE_OFFSET, _storage_offset, 0);
  }
  const flatbuffers::Vector<int32_t> *sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZES);
  }
  flatbuffers::Vector<int32_t> *mutable_sizes() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_SIZES);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  flatbuffers::Vector<int32_t> *mutable_strides() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  bool requires_grad() const {
    return GetField<uint8_t>(VT_REQUIRES_GRAD, 0) != 0;
  }
  bool mutate_requires_grad(bool _requires_grad = 0) {
    return SetField<uint8_t>(VT_REQUIRES_GRAD, static_cast<uint8_t>(_requires_grad), 0);
  }
  const executorch::QuantizedSchema *quantized_schema() const {
    return GetPointer<const executorch::QuantizedSchema *>(VT_QUANTIZED_SCHEMA);
  }
  executorch::QuantizedSchema *mutable_quantized_schema() {
    return GetPointer<executorch::QuantizedSchema *>(VT_QUANTIZED_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER_INDEX, 4) &&
           VerifyField<int8_t>(verifier, VT_SCALAR_TYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_STORAGE_OFFSET, 4) &&
           VerifyOffset(verifier, VT_SIZES) &&
           verifier.VerifyVector(sizes()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRES_GRAD, 1) &&
           VerifyOffset(verifier, VT_QUANTIZED_SCHEMA) &&
           verifier.VerifyTable(quantized_schema()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer_index(uint32_t buffer_index) {
    fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER_INDEX, buffer_index, 0);
  }
  void add_scalar_type(int8_t scalar_type) {
    fbb_.AddElement<int8_t>(Tensor::VT_SCALAR_TYPE, scalar_type, 0);
  }
  void add_storage_offset(int32_t storage_offset) {
    fbb_.AddElement<int32_t>(Tensor::VT_STORAGE_OFFSET, storage_offset, 0);
  }
  void add_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> sizes) {
    fbb_.AddOffset(Tensor::VT_SIZES, sizes);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(Tensor::VT_STRIDES, strides);
  }
  void add_requires_grad(bool requires_grad) {
    fbb_.AddElement<uint8_t>(Tensor::VT_REQUIRES_GRAD, static_cast<uint8_t>(requires_grad), 0);
  }
  void add_quantized_schema(flatbuffers::Offset<executorch::QuantizedSchema> quantized_schema) {
    fbb_.AddOffset(Tensor::VT_QUANTIZED_SCHEMA, quantized_schema);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t buffer_index = 0,
    int8_t scalar_type = 0,
    int32_t storage_offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    bool requires_grad = false,
    flatbuffers::Offset<executorch::QuantizedSchema> quantized_schema = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_quantized_schema(quantized_schema);
  builder_.add_strides(strides);
  builder_.add_sizes(sizes);
  builder_.add_storage_offset(storage_offset);
  builder_.add_buffer_index(buffer_index);
  builder_.add_requires_grad(requires_grad);
  builder_.add_scalar_type(scalar_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t buffer_index = 0,
    int8_t scalar_type = 0,
    int32_t storage_offset = 0,
    const std::vector<int32_t> *sizes = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    bool requires_grad = false,
    flatbuffers::Offset<executorch::QuantizedSchema> quantized_schema = 0) {
  auto sizes__ = sizes ? _fbb.CreateVector<int32_t>(*sizes) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return executorch::CreateTensor(
      _fbb,
      buffer_index,
      scalar_type,
      storage_offset,
      sizes__,
      strides__,
      requires_grad,
      quantized_schema);
}

struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRING_VAL = 4
  };
  const flatbuffers::String *string_val() const {
    return GetPointer<const flatbuffers::String *>(VT_STRING_VAL);
  }
  flatbuffers::String *mutable_string_val() {
    return GetPointer<flatbuffers::String *>(VT_STRING_VAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRING_VAL) &&
           verifier.VerifyString(string_val()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  typedef String Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_string_val(flatbuffers::Offset<flatbuffers::String> string_val) {
    fbb_.AddOffset(String::VT_STRING_VAL, string_val);
  }
  explicit StringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<String>(end);
    return o;
  }
};

inline flatbuffers::Offset<String> CreateString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> string_val = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_string_val(string_val);
  return builder_.Finish();
}

inline flatbuffers::Offset<String> CreateStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *string_val = nullptr) {
  auto string_val__ = string_val ? _fbb.CreateString(string_val) : 0;
  return executorch::CreateString(
      _fbb,
      string_val__);
}

struct IntList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<int64_t> *items() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ITEMS);
  }
  flatbuffers::Vector<int64_t> *mutable_items() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct IntListBuilder {
  typedef IntList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<int64_t>> items) {
    fbb_.AddOffset(IntList::VT_ITEMS, items);
  }
  explicit IntListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IntList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntList>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntList> CreateIntList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> items = 0) {
  IntListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntList> CreateIntListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<int64_t>(*items) : 0;
  return executorch::CreateIntList(
      _fbb,
      items__);
}

struct DoubleList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoubleListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<double> *items() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ITEMS);
  }
  flatbuffers::Vector<double> *mutable_items() {
    return GetPointer<flatbuffers::Vector<double> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct DoubleListBuilder {
  typedef DoubleList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<double>> items) {
    fbb_.AddOffset(DoubleList::VT_ITEMS, items);
  }
  explicit DoubleListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DoubleList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DoubleList>(end);
    return o;
  }
};

inline flatbuffers::Offset<DoubleList> CreateDoubleList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> items = 0) {
  DoubleListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<DoubleList> CreateDoubleListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<double>(*items) : 0;
  return executorch::CreateDoubleList(
      _fbb,
      items__);
}

struct BoolList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoolListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint8_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  flatbuffers::Vector<uint8_t> *mutable_items() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct BoolListBuilder {
  typedef BoolList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items) {
    fbb_.AddOffset(BoolList::VT_ITEMS, items);
  }
  explicit BoolListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BoolList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoolList>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoolList> CreateBoolList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items = 0) {
  BoolListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<BoolList> CreateBoolListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint8_t>(*items) : 0;
  return executorch::CreateBoolList(
      _fbb,
      items__);
}

struct TensorList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<executorch::Tensor>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<executorch::Tensor>> *>(VT_ITEMS);
  }
  flatbuffers::Vector<flatbuffers::Offset<executorch::Tensor>> *mutable_items() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<executorch::Tensor>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct TensorListBuilder {
  typedef TensorList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::Tensor>>> items) {
    fbb_.AddOffset(TensorList::VT_ITEMS, items);
  }
  explicit TensorListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorList>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorList> CreateTensorList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::Tensor>>> items = 0) {
  TensorListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorList> CreateTensorListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<executorch::Tensor>> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<flatbuffers::Offset<executorch::Tensor>>(*items) : 0;
  return executorch::CreateTensorList(
      _fbb,
      items__);
}

struct EValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL_TYPE = 4,
    VT_VAL = 6
  };
  executorch::ValueUnion val_type() const {
    return static_cast<executorch::ValueUnion>(GetField<uint8_t>(VT_VAL_TYPE, 0));
  }
  const void *val() const {
    return GetPointer<const void *>(VT_VAL);
  }
  template<typename T> const T *val_as() const;
  const executorch::Int *val_as_Int() const {
    return val_type() == executorch::ValueUnion::Int ? static_cast<const executorch::Int *>(val()) : nullptr;
  }
  const executorch::Bool *val_as_Bool() const {
    return val_type() == executorch::ValueUnion::Bool ? static_cast<const executorch::Bool *>(val()) : nullptr;
  }
  const executorch::Double *val_as_Double() const {
    return val_type() == executorch::ValueUnion::Double ? static_cast<const executorch::Double *>(val()) : nullptr;
  }
  const executorch::Tensor *val_as_Tensor() const {
    return val_type() == executorch::ValueUnion::Tensor ? static_cast<const executorch::Tensor *>(val()) : nullptr;
  }
  const executorch::String *val_as_String() const {
    return val_type() == executorch::ValueUnion::String ? static_cast<const executorch::String *>(val()) : nullptr;
  }
  const executorch::IntList *val_as_IntList() const {
    return val_type() == executorch::ValueUnion::IntList ? static_cast<const executorch::IntList *>(val()) : nullptr;
  }
  const executorch::DoubleList *val_as_DoubleList() const {
    return val_type() == executorch::ValueUnion::DoubleList ? static_cast<const executorch::DoubleList *>(val()) : nullptr;
  }
  const executorch::BoolList *val_as_BoolList() const {
    return val_type() == executorch::ValueUnion::BoolList ? static_cast<const executorch::BoolList *>(val()) : nullptr;
  }
  const executorch::TensorList *val_as_TensorList() const {
    return val_type() == executorch::ValueUnion::TensorList ? static_cast<const executorch::TensorList *>(val()) : nullptr;
  }
  void *mutable_val() {
    return GetPointer<void *>(VT_VAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL_TYPE, 1) &&
           VerifyOffset(verifier, VT_VAL) &&
           VerifyValueUnion(verifier, val(), val_type()) &&
           verifier.EndTable();
  }
};

template<> inline const executorch::Int *EValue::val_as<executorch::Int>() const {
  return val_as_Int();
}

template<> inline const executorch::Bool *EValue::val_as<executorch::Bool>() const {
  return val_as_Bool();
}

template<> inline const executorch::Double *EValue::val_as<executorch::Double>() const {
  return val_as_Double();
}

template<> inline const executorch::Tensor *EValue::val_as<executorch::Tensor>() const {
  return val_as_Tensor();
}

template<> inline const executorch::String *EValue::val_as<executorch::String>() const {
  return val_as_String();
}

template<> inline const executorch::IntList *EValue::val_as<executorch::IntList>() const {
  return val_as_IntList();
}

template<> inline const executorch::DoubleList *EValue::val_as<executorch::DoubleList>() const {
  return val_as_DoubleList();
}

template<> inline const executorch::BoolList *EValue::val_as<executorch::BoolList>() const {
  return val_as_BoolList();
}

template<> inline const executorch::TensorList *EValue::val_as<executorch::TensorList>() const {
  return val_as_TensorList();
}

struct EValueBuilder {
  typedef EValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_val_type(executorch::ValueUnion val_type) {
    fbb_.AddElement<uint8_t>(EValue::VT_VAL_TYPE, static_cast<uint8_t>(val_type), 0);
  }
  void add_val(flatbuffers::Offset<void> val) {
    fbb_.AddOffset(EValue::VT_VAL, val);
  }
  explicit EValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<EValue> CreateEValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    executorch::ValueUnion val_type = executorch::ValueUnion::NONE,
    flatbuffers::Offset<void> val = 0) {
  EValueBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_val_type(val_type);
  return builder_.Finish();
}

struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OVERLOAD = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *overload() const {
    return GetPointer<const flatbuffers::String *>(VT_OVERLOAD);
  }
  flatbuffers::String *mutable_overload() {
    return GetPointer<flatbuffers::String *>(VT_OVERLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_OVERLOAD) &&
           verifier.VerifyString(overload()) &&
           verifier.EndTable();
  }
};

struct OperatorBuilder {
  typedef Operator Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Operator::VT_NAME, name);
  }
  void add_overload(flatbuffers::Offset<flatbuffers::String> overload) {
    fbb_.AddOffset(Operator::VT_OVERLOAD, overload);
  }
  explicit OperatorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline flatbuffers::Offset<Operator> CreateOperator(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> overload = 0) {
  OperatorBuilder builder_(_fbb);
  builder_.add_overload(overload);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Operator> CreateOperatorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *overload = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto overload__ = overload ? _fbb.CreateString(overload) : 0;
  return executorch::CreateOperator(
      _fbb,
      name__,
      overload__);
}

struct Kernel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KernelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_INDEX = 4,
    VT_ARGS = 6
  };
  int32_t op_index() const {
    return GetField<int32_t>(VT_OP_INDEX, 0);
  }
  bool mutate_op_index(int32_t _op_index = 0) {
    return SetField<int32_t>(VT_OP_INDEX, _op_index, 0);
  }
  const flatbuffers::Vector<int32_t> *args() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ARGS);
  }
  flatbuffers::Vector<int32_t> *mutable_args() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OP_INDEX, 4) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.EndTable();
  }
};

struct KernelBuilder {
  typedef Kernel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_op_index(int32_t op_index) {
    fbb_.AddElement<int32_t>(Kernel::VT_OP_INDEX, op_index, 0);
  }
  void add_args(flatbuffers::Offset<flatbuffers::Vector<int32_t>> args) {
    fbb_.AddOffset(Kernel::VT_ARGS, args);
  }
  explicit KernelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Kernel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Kernel>(end);
    return o;
  }
};

inline flatbuffers::Offset<Kernel> CreateKernel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t op_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> args = 0) {
  KernelBuilder builder_(_fbb);
  builder_.add_args(args);
  builder_.add_op_index(op_index);
  return builder_.Finish();
}

inline flatbuffers::Offset<Kernel> CreateKernelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t op_index = 0,
    const std::vector<int32_t> *args = nullptr) {
  auto args__ = args ? _fbb.CreateVector<int32_t>(*args) : 0;
  return executorch::CreateKernel(
      _fbb,
      op_index,
      args__);
}

struct Chain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChainBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTS = 4,
    VT_OUTPUTS = 6,
    VT_KERNELS = 8,
    VT_INSTRUCTIONS = 10
  };
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  flatbuffers::Vector<int32_t> *mutable_inputs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  flatbuffers::Vector<int32_t> *mutable_outputs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<executorch::Kernel>> *kernels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<executorch::Kernel>> *>(VT_KERNELS);
  }
  flatbuffers::Vector<flatbuffers::Offset<executorch::Kernel>> *mutable_kernels() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<executorch::Kernel>> *>(VT_KERNELS);
  }
  const flatbuffers::Vector<const executorch::Instruction *> *instructions() const {
    return GetPointer<const flatbuffers::Vector<const executorch::Instruction *> *>(VT_INSTRUCTIONS);
  }
  flatbuffers::Vector<const executorch::Instruction *> *mutable_instructions() {
    return GetPointer<flatbuffers::Vector<const executorch::Instruction *> *>(VT_INSTRUCTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_KERNELS) &&
           verifier.VerifyVector(kernels()) &&
           verifier.VerifyVectorOfTables(kernels()) &&
           VerifyOffset(verifier, VT_INSTRUCTIONS) &&
           verifier.VerifyVector(instructions()) &&
           verifier.EndTable();
  }
};

struct ChainBuilder {
  typedef Chain Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(Chain::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(Chain::VT_OUTPUTS, outputs);
  }
  void add_kernels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::Kernel>>> kernels) {
    fbb_.AddOffset(Chain::VT_KERNELS, kernels);
  }
  void add_instructions(flatbuffers::Offset<flatbuffers::Vector<const executorch::Instruction *>> instructions) {
    fbb_.AddOffset(Chain::VT_INSTRUCTIONS, instructions);
  }
  explicit ChainBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Chain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Chain>(end);
    return o;
  }
};

inline flatbuffers::Offset<Chain> CreateChain(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::Kernel>>> kernels = 0,
    flatbuffers::Offset<flatbuffers::Vector<const executorch::Instruction *>> instructions = 0) {
  ChainBuilder builder_(_fbb);
  builder_.add_instructions(instructions);
  builder_.add_kernels(kernels);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<Chain> CreateChainDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<executorch::Kernel>> *kernels = nullptr,
    const std::vector<executorch::Instruction> *instructions = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto kernels__ = kernels ? _fbb.CreateVector<flatbuffers::Offset<executorch::Kernel>>(*kernels) : 0;
  auto instructions__ = instructions ? _fbb.CreateVectorOfStructs<executorch::Instruction>(*instructions) : 0;
  return executorch::CreateChain(
      _fbb,
      inputs__,
      outputs__,
      kernels__,
      instructions__);
}

struct ExecutionPlan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecutionPlanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_CHAINS = 10,
    VT_OPERATORS = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<executorch::EValue>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<executorch::EValue>> *>(VT_VALUES);
  }
  flatbuffers::Vector<flatbuffers::Offset<executorch::EValue>> *mutable_values() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<executorch::EValue>> *>(VT_VALUES);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  flatbuffers::Vector<int32_t> *mutable_inputs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  flatbuffers::Vector<int32_t> *mutable_outputs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<executorch::Chain>> *chains() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<executorch::Chain>> *>(VT_CHAINS);
  }
  flatbuffers::Vector<flatbuffers::Offset<executorch::Chain>> *mutable_chains() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<executorch::Chain>> *>(VT_CHAINS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<executorch::Operator>> *operators() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<executorch::Operator>> *>(VT_OPERATORS);
  }
  flatbuffers::Vector<flatbuffers::Offset<executorch::Operator>> *mutable_operators() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<executorch::Operator>> *>(VT_OPERATORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_CHAINS) &&
           verifier.VerifyVector(chains()) &&
           verifier.VerifyVectorOfTables(chains()) &&
           VerifyOffset(verifier, VT_OPERATORS) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           verifier.EndTable();
  }
};

struct ExecutionPlanBuilder {
  typedef ExecutionPlan Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::EValue>>> values) {
    fbb_.AddOffset(ExecutionPlan::VT_VALUES, values);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(ExecutionPlan::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(ExecutionPlan::VT_OUTPUTS, outputs);
  }
  void add_chains(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::Chain>>> chains) {
    fbb_.AddOffset(ExecutionPlan::VT_CHAINS, chains);
  }
  void add_operators(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::Operator>>> operators) {
    fbb_.AddOffset(ExecutionPlan::VT_OPERATORS, operators);
  }
  explicit ExecutionPlanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecutionPlan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutionPlan>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutionPlan> CreateExecutionPlan(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::EValue>>> values = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::Chain>>> chains = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::Operator>>> operators = 0) {
  ExecutionPlanBuilder builder_(_fbb);
  builder_.add_operators(operators);
  builder_.add_chains(chains);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecutionPlan> CreateExecutionPlanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<executorch::EValue>> *values = nullptr,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<executorch::Chain>> *chains = nullptr,
    const std::vector<flatbuffers::Offset<executorch::Operator>> *operators = nullptr) {
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<executorch::EValue>>(*values) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto chains__ = chains ? _fbb.CreateVector<flatbuffers::Offset<executorch::Chain>>(*chains) : 0;
  auto operators__ = operators ? _fbb.CreateVector<flatbuffers::Offset<executorch::Operator>>(*operators) : 0;
  return executorch::CreateExecutionPlan(
      _fbb,
      values__,
      inputs__,
      outputs__,
      chains__,
      operators__);
}

struct Program FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProgramBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_EXECUTION_PLAN = 6,
    VT_BUFFERS = 8
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version = 0) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<executorch::ExecutionPlan>> *execution_plan() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<executorch::ExecutionPlan>> *>(VT_EXECUTION_PLAN);
  }
  flatbuffers::Vector<flatbuffers::Offset<executorch::ExecutionPlan>> *mutable_execution_plan() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<executorch::ExecutionPlan>> *>(VT_EXECUTION_PLAN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<executorch::Buffer>> *buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<executorch::Buffer>> *>(VT_BUFFERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<executorch::Buffer>> *mutable_buffers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<executorch::Buffer>> *>(VT_BUFFERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_EXECUTION_PLAN) &&
           verifier.VerifyVector(execution_plan()) &&
           verifier.VerifyVectorOfTables(execution_plan()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           verifier.EndTable();
  }
};

struct ProgramBuilder {
  typedef Program Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Program::VT_VERSION, version, 0);
  }
  void add_execution_plan(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::ExecutionPlan>>> execution_plan) {
    fbb_.AddOffset(Program::VT_EXECUTION_PLAN, execution_plan);
  }
  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::Buffer>>> buffers) {
    fbb_.AddOffset(Program::VT_BUFFERS, buffers);
  }
  explicit ProgramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Program> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Program>(end);
    return o;
  }
};

inline flatbuffers::Offset<Program> CreateProgram(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::ExecutionPlan>>> execution_plan = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<executorch::Buffer>>> buffers = 0) {
  ProgramBuilder builder_(_fbb);
  builder_.add_buffers(buffers);
  builder_.add_execution_plan(execution_plan);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Program> CreateProgramDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const std::vector<flatbuffers::Offset<executorch::ExecutionPlan>> *execution_plan = nullptr,
    const std::vector<flatbuffers::Offset<executorch::Buffer>> *buffers = nullptr) {
  auto execution_plan__ = execution_plan ? _fbb.CreateVector<flatbuffers::Offset<executorch::ExecutionPlan>>(*execution_plan) : 0;
  auto buffers__ = buffers ? _fbb.CreateVector<flatbuffers::Offset<executorch::Buffer>>(*buffers) : 0;
  return executorch::CreateProgram(
      _fbb,
      version,
      execution_plan__,
      buffers__);
}

inline bool VerifyValueUnion(flatbuffers::Verifier &verifier, const void *obj, ValueUnion type) {
  switch (type) {
    case ValueUnion::NONE: {
      return true;
    }
    case ValueUnion::Int: {
      return verifier.VerifyField<executorch::Int>(static_cast<const uint8_t *>(obj), 0, 8);
    }
    case ValueUnion::Bool: {
      return verifier.VerifyField<executorch::Bool>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case ValueUnion::Double: {
      return verifier.VerifyField<executorch::Double>(static_cast<const uint8_t *>(obj), 0, 8);
    }
    case ValueUnion::Tensor: {
      auto ptr = reinterpret_cast<const executorch::Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnion::String: {
      auto ptr = reinterpret_cast<const executorch::String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnion::IntList: {
      auto ptr = reinterpret_cast<const executorch::IntList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnion::DoubleList: {
      auto ptr = reinterpret_cast<const executorch::DoubleList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnion::BoolList: {
      auto ptr = reinterpret_cast<const executorch::BoolList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnion::TensorList: {
      auto ptr = reinterpret_cast<const executorch::TensorList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ValueUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValueUnion(
        verifier,  values->Get(i), types->GetEnum<ValueUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const executorch::Program *GetProgram(const void *buf) {
  return flatbuffers::GetRoot<executorch::Program>(buf);
}

inline const executorch::Program *GetSizePrefixedProgram(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<executorch::Program>(buf);
}

inline Program *GetMutableProgram(void *buf) {
  return flatbuffers::GetMutableRoot<Program>(buf);
}

inline executorch::Program *GetMutableSizePrefixedProgram(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<executorch::Program>(buf);
}

inline const char *ProgramIdentifier() {
  return "ET01";
}

inline bool ProgramBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ProgramIdentifier());
}

inline bool SizePrefixedProgramBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ProgramIdentifier(), true);
}

inline bool VerifyProgramBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<executorch::Program>(ProgramIdentifier());
}

inline bool VerifySizePrefixedProgramBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<executorch::Program>(ProgramIdentifier());
}

inline const char *ProgramExtension() {
  return "extorch";
}

inline void FinishProgramBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<executorch::Program> root) {
  fbb.Finish(root, ProgramIdentifier());
}

inline void FinishSizePrefixedProgramBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<executorch::Program> root) {
  fbb.FinishSizePrefixed(root, ProgramIdentifier());
}

}  // namespace executorch

#endif  // FLATBUFFERS_GENERATED_SCHEMA_EXECUTORCH_H_
